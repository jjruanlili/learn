java序列化
1.实体类继承Serializable,使用transient关键字的字段不会被序列化  通过ObjectOutputStream序列化和ObjectInputStream反序列化
class Book implements Serializable
	/** 书名 */
	private String name;
	/** ISBN */
	private transient String isbn;
	/** 作者 */
	private transient List<String> authors;

2.实体类继承Serializable,编写私有方法writeObject和readObject,注意返回类型为void,只会对两个方法中处理过的字段进行序列化和反序列化
class Book implements Serializable
	/** 书名 */
	private String name;
	/** ISBN */
	private String isbn;
	/** 作者 */
	private List<String> authors;
	private void writeObject(ObjectOutputStream oos) throws IOException {
		// oos.defaultWriteObject();
		oos.writeObject(name);
		oos.writeObject(isbn);
	}
	private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
		// ois.defaultReadObject();
		name = (String) ois.readObject();
		isbn = (String) ois.readObject();
	}

3.实体类继承Externalizable,实现writeExternal以及readExternal方法,write为序列化方法,read为反序列化方法
class Book implements Externalizable
    /** 书名 */
	private String name;
	/** ISBN */
	private String isbn;
	/** 作者 */
	private List<String> authors;
	@Override
	public void writeExternal(ObjectOutput out) throws IOException {
		out.writeObject(name);
		out.writeObject(isbn);
	}
	@Override
	public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
		name = (String) in.readObject();
		isbn = (String) in.readObject();
	}

java中List、Set、Map区别




java static关键字
static方法就是没有this的方法。在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际上正是static方法的主要用途。

1.static方法  
一般称作静态方法，由于静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有this的。比如:MyUtil.getDate()不需要new对象就能直接使用这些方法

2.static变量  static变量也称作静态变量
静态变量和非静态变量的区别：
静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。
非静态变量是对象所拥有的，会存在多个副本，在创建对象的时候被初始化，各个对象拥有的副本互不影响。
static成员变量的初始化顺序按照定义的顺序进行初始化。

3.static代码块
静态代码块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次，可以优化程序性能。



final关键字
通常指的是这是无法改变的。
1.final数据
	1.1一个永不改变的编译时常量(必须是基本数据类型)
	1.2一个在运行时被初始化的值，而且不希望被改变
	1.3final参数：若是基本类型，则无法改变值；若是引用，则无法在方法中更改参数引用所指向的对象
	一个既是static又是final的域只占据一段不能改变的存储空间(大写表示，下划线分隔单词)。对于基本类型，final使数值恒定不变；而用于对象引用，final使引用恒定不变(无法再次指向另一个新的对象)。
2.final方法
	把方法锁定，以防止任何继承类修改它的含义。出于设计考虑：想要确保在继承中使方法行为保持不变，并且不会被覆盖。
	private方法都隐式地指定为是final
3.final类
	表明你不打算继承该类，也不允许别人这样做。出于某种考虑，你对该类的设计永不需要做任何变动，或者出于安全的考虑，你不希望它又子类。
	final类的域可以根据个人意愿选择为是或不是final。不论类是否被定义为final，相同的规则都适用于定义为final的域。
	final类的所有方法都隐式指定为final的。

组合 has-a   有
继承 is-a    是


面向对象：数据抽象(封装)、继承、多态(动态绑定/后期绑定/运行时绑定)
封装通过合并特征和行为来创建新的数据类型。比如一个水果类
多态通过分离做什么和怎么做，从另一个角度将接口和实现分离开，消除类型之间的耦合关系。
继承允许将对象视为它自己本身的类型或其基类型(向上转型)来加以处理，而同一份代码也就可以毫无差别的运行在这些不同类型之上了。
多态方法调用允许一种类型表现出与其他相似类型之间的区别，只要他们都是从同一基类导出而来的，这种区别是根据方法行为的不同而表示出来的。
多态是一项让程序员“将改变的事物与未变的事物分离开来”的重要技术。
只有普通的方法调用可以是多态的。任何域访问操作将由编译器解析，因此不是多态的。
向上转型：Shape shape = new Circle();
多态意味着“不同的形式”。在面向对象的程序设计中，我们持有从基类继承而来的相同接口，以及使用该接口的不同形式：不同版本的动态绑定方法。



java绑定
将一个方法调用同一个方法主体关联起来被称作绑定。
若在程序执行前进行绑定(如果有的话，由编译器和连接程序实现)，叫做前期绑定。(面向过程的语言中不需要选择就默认的绑定方式,例如,C语言只有这一种)
在运行时根据对象的类型进行绑定，叫做多态(后期绑定，也叫动态绑定或运行时绑定)。
编译器一致不知道对象的类型，但是方法调用机制能找到正确的方法体，并加以调用。
java中除了static方法和final方法(private方法属于final方法)之外，其他所有的方法都是后期绑定

构造动作一经发生，那么对象所有部分的全体成员都会得到构建。

Glyph.draw()方法设计为将要被覆盖，这种覆盖是在RoundGlyph中发生的。但是Glyph构造器会调用这个方法，结果导致了对RoundGlyph.draw()的调用，这看起来似乎是我们的目的。但是如果看到输出结果，我们会发现当Glyph的构造器调用draw()方法时，radius不是默认初始值1,而是0。
初始化的实际过程:
1)在其他任何事物发生之前，将分配给对象的存储空间初始化成二进制的零。
2)如前述那样调用基类构造器。此时，调用被覆盖后的draw()方法(要在调用RoundGlyph构造器之前调用)，由于步骤1的缘故，我们此时会发现radius的值为0.
3)按照声明的顺序调用成员的初始化方法。
4)调用导出类的构造器主体。
这样做有一个优点，那就是所有东西都至少初始化成零(或者是某些特殊数据类型中与"零"等价的值)，而不是仅仅留作垃圾。包括通过"组合"而嵌入一个类内部的对象引用，其值是null。所以如果忘记为该引用进行初始化，就会在运行时出现异常。
因此，编写构造器时有一条有效的准则:"用尽可能简单的方法使对象进入正常状态；如果可以的话，避免调用其他方法"。在构造器内唯一能够安全调用的那些方法使基类中的final方法(private方法都隐式地指定为是final)。这些方法不能被覆盖，因此也不会出现上述令人惊讶的问题。

动态灵活  动态模式


接口


设计模式
策略模式:创建一个能够根据所传递的参数对象的不同而具有不同行为的方法。“你可以用任何你想要的对象来调用我的方法，只要你的对象遵循我的接口。”
这类方法包含所要执行的算法中固定不变的部分，而“策略”包含变化的部分。策略就是传递进去的参数对象，它包含要执行的代码。
适配器模式：适配器中的代码将接受你所拥有的接口，并产生你所需要的接口。
工厂模式：
迭代器模式
命令模式




内部类
内部类自动拥有对其外围类所有成员的访问权。
当某个外围类的对象创建了一个内部类对象时，此内部类对象必定会秘密地捕获一个指向那个外围类对象的引用。然后，你在访问此外围类的成员时，就是用那个引用来选择外围类的成员。
嵌套类
如果不需要内部类对象与其外围类对象之间有联系，那么可以将内部类声明为static。
普通的内部类对象隐式地保存了一个引用，指向创建它的外围类对象。当内部类是static时，就不是这样了。
嵌套类意味着：
1)要创建嵌套类的对象，并不需要其外围类的对象。
2)不能从嵌套类的对象中访问非静态的外围类对象。
普通内部类的字段与方法，只能放在类的外部层次上，所以普通的内部类不能有static数据和static字段，也不能包含嵌套类，但是嵌套类可以包含所有这些东西。

每个内部类都能独立地继承自一个(接口的)实现，所以无论外围类是否已经继承了某个(接口的)实现，对于内部类都没有影响。


容器--集合类   容器不能持有基本类型
set：每个值都只保存一个对象
map：允许你将某些对象与其他一些对象关联起来地关联数组
list：以特定的顺序保存一组元素  (与数组的区别:可添加元素、移除元素或自我调整尺寸大小，是一种可修改的序列)
	ArrayList：长于随机访问元素，插入和移除元素较慢
	LinkedList：代价较低的插入和删除操作，优化的顺序访问，随机访问相对较慢

迭代器
Iterator：(只能单向移动，在调用remove()之前必须先调用next())
1.使用方法iterator()要求容器返回一个Iterator。Iterator将准备好返回序列的第一个元素。
2.使用next()获得序列中的下一个元素。
3.使用hasNext()检查序列中是否还有元素。
4.使用remove()将迭代器新进返回的元素删除。

ListIterator：只能用于各种List类的访问，可以双向移动





异常处理
当抛出异常后，有几件事会随之发生。首先，同java中其他对象的创建一样，将使用new在堆上创建异常对象。然后，当前的执行路径(它不能继续下去)被终止，并且从当前环境中弹出对异常对象的引用。此时，异常处理机制接管程序，并开始寻找一个恰当的地方来继续执行程序。这个恰当的地方就是异常处理程序，它的任务是将程序从错误状态中回复，以使程序能够要么换一种方式运行，要么继续运行下去。
事务的基本保障是我们所需的在分布式计算中的异常处理。事务是计算机中的合同法，如果出了什么问题，我们只需要放弃整个计算。

捕获异常  try块

异常处理程序 catch
当异常被抛出时，异常处理机制将负责搜寻参数与异常类型相匹配的第一个处理程序。然后进入catch子句执行，此时认为异常得到了处理。

异常处理两种基本模型：终止模型和恢复模型
终止模型：将假设错误非常关键，以至于程序无法返回到异常发生的地方继续执行。一旦异常被抛出，就表明错误已无法挽回，也不能回来继续执行。
恢复模型：异常处理程序的工作是修正错误，然后重新尝试调用出问题的方法，并认为第二次能成功。(在遇见错误时不抛出异常，而是调用方法来修正该错误)
恢复模型导致耦合:恢复性的处理程序需要了解异常抛出的地点，这势必要包含依赖于抛出位置的非通用性代码，增加了代码编写和维护的困难。


异常说明 throws

printStackTrace() 栈轨迹

异常链

java标准异常
Throwable 
Error 编译时和系统错误
Exception 可以被抛出的基本类型
RuntimeException 不受检查异常

对inputfile对象的构造在其自己的try语句块中有效，如果构造失败，将进入外部的catch子句，而dispose()方法不会被调用。但是，如果构造成功，我们肯定想确保对象能够被清理，因此在构造之后立即创建了一个新的try语句块。执行清理的finally与内部的try块相关联。在这种方式中，finally子句在构造失败时时不会执行的，而在构造成功时总是执行。这种通用的清理管用法在构造器不抛出任何异常时也应该运用，其基本规则是：在创建需要清理的对象之后，立即进入一个try-finally语句块。




String
println()
printf()
format()

format输出格式化
%[argument_index$][flags][width][.precision]conversion
1.width控制一个域的最小尺寸，Formatter对象通过在必要时添加空格，来确保一个域至少达到某个长度。默认情况下，数据是右对齐，可以通过使用"-"标志来改变对齐方向。
2.precision指明最大尺寸。width可以应用于各种类型的数据转换，并且行为方式都一样。precision则不然，不是所有类型的数据都能使用precision，而且，应用于不同类型的数据转换时，precision的意义也不同。
2.1应用于String时，表示打印String时输出字符的最大数量。
2.2应用于浮点数时，表示小数部分要显示出来的位数(默认6位小数)，如果小数位数过多则舍入，太少则在尾部补零。
2.3由于整数没有小数部分，所以对整数应用precision会触发异常。
3.conversion就是s字符,d十进制数,f浮点数
4.flags 比如"%,d"，逗号意思把金额用","千分位隔开;"%08d"，0是flag表示填充0，8是width输出8位
5.argument_index "%2$d, %1$d" 1$2$就是下标,按后面参数的顺序插入位置中


正则表达式
? 可能有
\d 表示数字
\\d 一位数字
+ 一个或多个之前的表达式
String.matches("-?\\d+")
(-|\\+)? 可能有一个-或+，或都没有
\W 非单词字符
\w 一个单词字符 注意大小写

类型信息
RTTI Run-Time Type Identification 在运行时，识别一个对象的类型

Class对象
Class对象是用来创建类的所有的"常规"对象的，java使用Class对象来执行RTTI(Run-Time Type Identification在运行时，识别一个对象的类型)。类是程序的一部分，每个类都有一个Class对象。即每当编写并且编译了一个新类，就会产生一个Class对象(被保存在一个同名的.class文件中)。和其他对象一样，我们可以获取并操作它的引用(这也就是类加载器的工作)。
所有的类都是在对其第一次使用时，动态加载到JVM中。
Class.forNmae(name)  必须使用全限定名(包含包名)
getClass()获取Class引用，返回该对象的实际类型的Class引用。
new Instance()创建,必须有默认构造器

xx.class形式创建Class对象
1.加载。这是由类加载器执行的。该步骤将查找字节码(通常在classpath所指定的路径中查找，但这并非是必需的)，并从这些字节码中创建一个Class对象。
2.链接。在链接阶段将验证类中的字节码，为静态域分配存储空间，并且如果必需的话，将解析这个类创建的对其他类的所有引用。
3.初始化。如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块。

static final修饰的编译期常量可以不对类初始化获取；也有可能修饰的不是编译期常量，则会先对类进行初始化。
如果一个static域不是final的，那么在对它访问时，总是要求在它被读取之前，要先进行链接(为这个域分配存储空间)和初始化(初始化该存储空间)。

Class引用总是指向某个Class对象，它可以制造类的实例，并包含可作用于这些实例的所有方法代码，还包含该类的静态成员。Class引用表示的就是它所指向的对象的确切类型，而该对象便是Class类的一个对象。
Class也可以使用泛型 Class<Integer>，来提供编译器类型检查;普通的类引用可以被重新赋值指向任何其他的Class对象(可以在泛型中使用通配符?达到相同目的),泛型修饰的不行。

模式
注册工厂


反射
RMI远程方法调用

动态代理   Proxy.newProxyInstance()    InvocationHandler
代理是基本设计模式之一
动态代理组装
1、一个目标对象
2、一个handler对象 继承 InvocationHandler，将目标对象通过构造器包进去
3、通过Proxy.newProxyInstance()创建动态代理，动态代理可以将所有调用重定向到调用处理器





